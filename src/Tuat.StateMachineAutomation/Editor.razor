@using Blazor.Diagrams;
@using Blazor.Diagrams.Components
@using Blazor.Diagrams.Components.Widgets;
@using Blazor.Diagrams.Core.Anchors
@using Blazor.Diagrams.Core.Geometry;
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Core.Models.Base
@using Blazor.Diagrams.Core.PathGenerators;
@using Blazor.Diagrams.Core.Routers;
@using Blazor.Diagrams.Options;
@using Microsoft.JSInterop
@using Radzen
@using Radzen.Blazor
@using Tuat.Dialogs
@using Tuat.Interfaces
@using Tuat.Models
@inject Tuat.Interfaces.IClientService ClientService
@inject Tuat.Interfaces.IAutomationService AutomationService
@inject DialogService DialogService
@inject ContextMenuService ContextMenuService
@inject IClipboardService ClipboardService
@inject IJSRuntime JS
@implements IAutomationEditor
@implements IDisposable

@if (ScriptEditorType != null)
{
	<div class="diagram-container" style="width: 100%; height: 70vh; border: 1px solid black; position: relative;" @oncontextmenu="OnContextMenu" @oncontextmenu:preventDefault="true">

		<div style="position: absolute; top: 10px; left: 10px; z-index: 10;" @oncontextmenu:preventDefault="false">
			<RadzenButton Size="ButtonSize.Small" Text="Pre Start Action " Click="EditPreStartActionAsync" />
		</div>

		<div style="position: absolute; top: 10px; right: 10px; z-index: 10;" @oncontextmenu:preventDefault="false">
			<RadzenUpload Icon="upload" ChooseText="Import" Auto=true Multiple=false Accept="text/json" Change=@(args => OnImport(args)) InputAttributes="@(new Dictionary<string, object>() { { "aria-label", "Import" } })" />
 			<RadzenButton Size="ButtonSize.Small" Text="+" Click="@(() => _diagram.SetZoom(_diagram.Zoom * 1.25))" />
			<RadzenButton Size="ButtonSize.Small" Text="-" Click="@(() => _diagram.SetZoom(_diagram.Zoom * 0.75))" />
			<RadzenButton Size="ButtonSize.Small" Text="Reset" Click="@(() => _diagram.SetZoom(1.0))" />
			<RadzenButton Size="ButtonSize.Small" Text="Fit" Click="@(() => _diagram.ZoomToFit())" />
		</div>

		<CascadingValue Value="_diagram" IsFixed="true">
			<DiagramCanvas>
				<Widgets>
					<SelectionBoxWidget />
				</Widgets>
			</DiagramCanvas>
		</CascadingValue>
	</div>
}

@code {
    [Parameter]
    public Automation Automation { get; set; } = null!;

    [Parameter]
    public string? Height { get; set; }

    [Parameter]
    public Type? ScriptEditorType { get; set; }

    [Parameter]
    public EventCallback OnRestart { get; set; }

    [Parameter]
    public EventCallback OnSave { get; set; }

    [Parameter]
    public EventCallback OnEditSettings { get; set; }


    private sealed class NodeUIData
    {
        public int X { get; set; } = 50;
        public int Y { get; set; } = 50;
    }

    private sealed class LinkUIData
    {
        public PortAlignment SourcePort { get; set; } = PortAlignment.Bottom;
        public PortAlignment TargetPort { get; set; } = PortAlignment.Top;
    }



    BlazorDiagram _diagram = null!;
    bool _draggingElement;
    IScriptEngine? _scriptEngine;
    AutomationProperties _automationProperties = null!;
    StateMachineHandler _stateMachineHandler = null!;
    UndoRedo<string> _undoRedo = new();

    protected override async Task OnInitializedAsync()
    {
        _stateMachineHandler = (StateMachineHandler)AutomationService.GetAutomation(Automation.Id);
        _automationProperties = StateMachineHandler.GetAutomationProperties(Automation.Data);
        _scriptEngine = StateMachineHandler.GetScriptEngine(Automation.ScriptType);
        var options = new BlazorDiagramOptions
		{
			AllowMultiSelection = true,
			Zoom =
														{
						Enabled = true
														},
			Links =
														{
						DefaultRouter = new NormalRouter(),
						DefaultPathGenerator = new SmoothPathGenerator(),
						RequireTarget = true,
						Factory = (diagram, source, targetAnchor) =>
						{
							Anchor? source2;
							if (!(source is NodeModel model3))
							{
								if (!(source is PortModel port2))
								{
									throw new NotImplementedException();
								}

								source2 = new SinglePortAnchor(port2);
							}
							else
							{
								source2 = new ShapeIntersectionAnchor(model3);
							}

							var linkModel = new LinkModel(source2, targetAnchor);
							linkModel.TargetMarker = LinkMarker.Arrow;
							linkModel.AddLabel("true");
							_draggingElement = true;
							return linkModel;
						}														
					}
		};
        _diagram = new BlazorDiagram(options);
        _diagram.RegisterComponent<StateMachineStateNodeModel, StateMachineStateNodeWidget>();
        _diagram.RegisterComponent<StateMachineInformationNodeModel, StateMachineInformationNodeWidget>();

        var keyboardBehavior = _diagram.GetBehavior<Blazor.Diagrams.Core.Behaviors.KeyboardShortcutsBehavior>();
        keyboardBehavior!.RemoveShortcut("g", ctrl: true, shift: false, alt: true);
        keyboardBehavior.RemoveShortcut("Delete", ctrl: false, shift: false, alt: false);
        keyboardBehavior.SetShortcut("Delete", ctrl: false, shift: false, alt: false, DeleteSelection);
        keyboardBehavior.SetShortcut("a", ctrl: true, shift: false, alt: false, SelectAll);
        keyboardBehavior.SetShortcut("z", ctrl: true, shift: false, alt: false, UndoAsync);
        keyboardBehavior.SetShortcut("y", ctrl: true, shift: false, alt: false, RedoAsync);
        _diagram.PointerDoubleClick += DiagramPointerDoubleClickAsync;
        _diagram.PointerUp += DiagramPointerUpAsync;
        _diagram.PointerMove += DiagramPointerMove;
        _diagram.PointerDown += DiagramPointerDown;

        await ReloadDiagramAsync();
        RefreshInformations();

        await base.OnInitializedAsync();
    }

    public void Dispose()
    {
        _diagram.PointerUp -= DiagramPointerUpAsync;
        _diagram.PointerMove -= DiagramPointerMove;
        _diagram.PointerDown -= DiagramPointerDown;
        _diagram.PointerDoubleClick -= DiagramPointerDoubleClickAsync;
    }

    public async Task ReloadAutomationAsync(Automation automation)
    {
        Automation = automation;
        _automationProperties = StateMachineHandler.GetAutomationProperties(Automation.Data);
        await ReloadDiagramAsync();
    }

    void Restart()
    {
        OnRestart.InvokeAsync();
    }

    public Task<string> GetAutomationDataAsync()
    {
        return Task.FromResult(System.Text.Json.JsonSerializer.Serialize(_automationProperties));
    }

    async Task SaveAsync()
    {
        await OnSave.InvokeAsync();
    }

    async Task EditPreStartActionAsync()
    {
        var result = await DialogService.ShowDialogAsync<ScriptEditorDialog, string?>("Pre Start Action", dialog =>
        {
            dialog.Script = _automationProperties.PreStartAction;
            dialog.ScriptEditorType = ScriptEditorType;
            dialog.ScriptEngine = _scriptEngine;
        });
        if (result != null)
        {
            _automationProperties.PreStartAction = result;
        }
    }

    Model? modelOnPointerUp = null;
    Blazor.Diagrams.Core.Geometry.Point? onContextPointerPosition = null;
    void OnContextMenu(MouseEventArgs args)
    {
        onContextPointerPosition = _diagram.GetRelativeMousePoint((int)args.ClientX, (int)args.ClientY);
        if (modelOnPointerUp is NodeModel node)
        {
            ContextMenuService.Open(args, ds =>
            @<RadzenMenu Click="OnNodeContextMenuItemClick">
                <RadzenMenuItem Text="Edit" Value="1"></RadzenMenuItem>
                <RadzenMenuItem Text="Copy" Value="3" Disabled="@(!_diagram.GetSelectedModels().Any())"></RadzenMenuItem>
                <RadzenMenuItem Text="Delete" Value="2"></RadzenMenuItem>
                <RadzenMenuItem Text="Edit Sub State Machine" Value="4" Disabled="@(!IsSubState())"></RadzenMenuItem>
            </RadzenMenu>);

        }
        else if (modelOnPointerUp is LinkModel link)
		{
            var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
            var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
            var sourceState = source.GetState(_automationProperties)!;
            var targetState = target.GetState(_automationProperties)!;

            ContextMenuService.Open(args, ds =>
                @<RadzenMenu Click="OnLinkContextMenuItemClick">
                            <RadzenMenuItem Text="Edit" Value="1"></RadzenMenuItem>
                            <RadzenMenuItem Text="Delete" Value="4"></RadzenMenuItem>
                            <RadzenMenuItem Text="Move Start To" Value="3">
                                @foreach (var state in _automationProperties.States.Where(x => x.Id != targetState.Id).ToList())
                                {
                                    <RadzenMenuItem Text="@(state.Name)" Value="21">
                                        <RadzenMenuItem Text="@(PortAlignment.Top.ToString())" Value="@((int)(30 + PortAlignment.Top))"></RadzenMenuItem>
                                        <RadzenMenuItem Text="@(PortAlignment.Left.ToString())" Value="@((int)(30 + PortAlignment.Left))"></RadzenMenuItem>
                                        <RadzenMenuItem Text="@(PortAlignment.Bottom.ToString())" Value="@((int)(30 + PortAlignment.Bottom))"></RadzenMenuItem>
                                        <RadzenMenuItem Text="@(PortAlignment.Right.ToString())" Value="@((int)(30 + PortAlignment.Right))"></RadzenMenuItem>
                                    </RadzenMenuItem>
                                }
                            </RadzenMenuItem>
                            <RadzenMenuItem Text="Move End To" Value="2">
                                @foreach (var state in _automationProperties.States.Where(x => x.Id != sourceState.Id).ToList())
                                {
                                    <RadzenMenuItem Text="@(state.Name)" Value="21">
                                        <RadzenMenuItem Text="@(PortAlignment.Top.ToString())" Value="@((int)(30 + PortAlignment.Top))"></RadzenMenuItem>
                                        <RadzenMenuItem Text="@(PortAlignment.Left.ToString())" Value="@((int)(30 + PortAlignment.Left))"></RadzenMenuItem>
                                        <RadzenMenuItem Text="@(PortAlignment.Bottom.ToString())" Value="@((int)(30 + PortAlignment.Bottom))"></RadzenMenuItem>
                                        <RadzenMenuItem Text="@(PortAlignment.Right.ToString())" Value="@((int)(30 + PortAlignment.Right))"></RadzenMenuItem>
                                    </RadzenMenuItem>
                                }
                </RadzenMenuItem>
            </RadzenMenu>);

		}
		else
		{
           ContextMenuService.Open(args, ds =>
			@<RadzenMenu Click="OnContextMenuItemClick">
			<RadzenMenuItem Text="Edit properties" Value="5"></RadzenMenuItem>
			<RadzenMenuItem Text="Add state" Value="1"></RadzenMenuItem>
			<RadzenMenuItem Text="Add information" Value="20"></RadzenMenuItem>
			<RadzenMenuItem Text="Save" Value="2"></RadzenMenuItem>
			<RadzenMenuItem Text="Copy" Value="8">
				<RadzenMenuItem Text="Selection" Value="9" Disabled="@(!_diagram.GetSelectedModels().Any())"></RadzenMenuItem>
				<RadzenMenuItem Text="All states and transitions" Disabled="@(!_automationProperties.Transitions.Any() && !_automationProperties.States.Any())" Value="10"></RadzenMenuItem>
				<RadzenMenuItem Text="Complete state machine" Value="11"></RadzenMenuItem>
			</RadzenMenuItem>
            <RadzenMenuItem Text="Paste" Value="12" Disabled="@(!ClipboardService.CanPaste("StateMachine"))"></RadzenMenuItem>
			<RadzenMenuItem Text="Undo" Value="14" Disabled="@(!CanUndo())"></RadzenMenuItem>
			<RadzenMenuItem Text="Redo" Value="15" Disabled="@(!CanRedo())"></RadzenMenuItem>
			<RadzenMenuItem Text="Select all" Value="13" Disabled="@(!_automationProperties.Transitions.Any() && !_automationProperties.States.Any())"></RadzenMenuItem>
			<RadzenMenuItem Text="Restart" Value="3"></RadzenMenuItem>
			<RadzenMenuItem Text="Reload" Value="4"></RadzenMenuItem>
			<RadzenMenuItem Text="Export" Value="7"></RadzenMenuItem>
		</RadzenMenu>
			);

		}
	}

    State? moveToState = null;
    bool changeTarget = false;
    async void OnLinkContextMenuItemClick(MenuItemEventArgs args)
    {
        var link = modelOnPointerUp as LinkModel;
        switch (args.Value)
        {
            case 1:
                ContextMenuService.Close();
                await EditTransitionAsync(link!);
                break;
            case 2:
                moveToState = null;
                changeTarget = true;
                break;
            case 3:
                moveToState = null;
                changeTarget = false;
                break;
            case 21:
                moveToState = _automationProperties.States.First(x => x.Name == args.Text);
                break;
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                //move end of link to top of selected state
                {
                    AddUndo();
                    //current situation
                    var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link!.Source).Port.Parent;
                    var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
                    var sourceState = source.GetState(_automationProperties)!;
                    var targetState = target.GetState(_automationProperties)!;
                    var transition = _automationProperties.Transitions.First(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
                    var sourcePort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Alignment;
                    var targetPort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Alignment;

                    var newPortAllignment = (PortAlignment)((int)args.Value - 30);

                    if (changeTarget)
                    {
                        transition.ToStateId = moveToState!.Id;
                        AddLink(transition, sourcePort, newPortAllignment);
                    }
                    else
                    {
                        transition.FromStateId = moveToState!.Id;
                        AddLink(transition, newPortAllignment, targetPort);
                    }

                    ContextMenuService.Close();
                    _diagram.Links.Remove(link!);
                    _diagram.Refresh();
                }
                break;
            case 4:
                {
                    ContextMenuService.Close();
                    AddUndo();
                    RemoveLink(link!);
                }
                break;
        }
    }

    async void OnNodeContextMenuItemClick(MenuItemEventArgs args)
    {
        ContextMenuService.Close();
        var node = modelOnPointerUp as NodeModel;
        switch (args.Value)
        {
            case 1:
                await EditStateAsync(node!);
                break;
            case 2:
                AddUndo();
                RemoveNode(node!);
                break;
            case 3:
                CopySelectionToClipboard();
                break;
            case 4:
                EditSubStateMachine(node!);
                break;
        }
    }

    async void OnContextMenuItemClick(MenuItemEventArgs args)
    {
        switch (args.Value)
        {
            case 1:
                {
                    AddUndo();
                    var p = onContextPointerPosition ?? _diagram.GetRelativeMousePoint((int)args.ClientX, (int)args.ClientY);
                    await AddStateAsync((int)p.X, (int)p.Y);
                }
                break;
            case 2:
                await SaveAsync();
                break;
            case 3:
                Restart();
                break;
            case 4:
                AddUndo();
                await ReloadDiagramAsync();
                break;
            case 5:
				SaveAutomationPropertiesToAutomation();
           		await OnEditSettings.InvokeAsync();
				await InvokeAsync(StateHasChanged);
                break;
            case 7:
                await ExportAsync();
                break;
            case 8:
                return;
            case 9:
                CopySelectionToClipboard();
                break;
            case 10:
                CopyAllStatesAndTransitionsToClipboard();
                break;
            case 11:
                CopyStateMachineToClipboard();
                break;
            case 12:
                PasteFromClipboard(args);
                break;
            case 13:
                await SelectAll(_diagram);
                break;
            case 14:
                await UndoAsync(_diagram);
                break;
            case 15:
                await RedoAsync(_diagram);
                break;
            // case 20:
            //     {
            //         AddUndo();
            //         var p = onContextPointerPosition ?? Diagram.GetRelativeMousePoint((int)args.ClientX, (int)args.ClientY);
            //         await AddInformationAsync((int)p.X, (int)p.Y);
            //     }
            //     break;
        }
		onContextPointerPosition = null;
		ContextMenuService.Close();
    }

    Stream GetFileStream()
    {
        var fileStream = new MemoryStream();

        AddUIDataToStatesAndTransitions();
        System.Text.Json.JsonSerializer.Serialize(fileStream, Automation);
        fileStream.Position = 0;

        return fileStream;
    }

    async Task ExportAsync()
    {
        var fileStream = GetFileStream();
        var fileName = "tuat_export_statemachine.json";

        using var streamRef = new DotNetStreamReference(stream: fileStream);

        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    void EditSubStateMachine(NodeModel node)
    {
        var state = node.GetState(_automationProperties)!;
        if (state.IsSubState && state.SubStateMachineId != null)
        {
            JS.InvokeVoidAsync("navigateToTarget", $"/editautomation/{state.SubStateMachineId}", "_blank");
        }
    }

    bool IsSubState()
    {
        if (modelOnPointerUp is StateMachineStateNodeModel node)
        {
            var state = node.GetState(_automationProperties)!;
            return state.IsSubState;
        }
        return false;
    }


    void CopyStateMachineToClipboard()
    {
        var content = new Dictionary<Type, object?>();

        AddUIDataToStatesAndTransitions();
        content.Add(typeof(Automation), Automation);

        ClipboardService.Copy("StateMachine", content);
    }

    void CopyAllStatesAndTransitionsToClipboard()
    {
        var content = new Dictionary<Type, object?>();

        AddUIDataToStatesAndTransitions();
        content.Add(typeof(List<State>), _automationProperties.States);
        content.Add(typeof(List<Transition>), _automationProperties.Transitions);

        ClipboardService.Copy("StateMachine", content);
    }

    void CopySelectionToClipboard()
    {
        var content = new Dictionary<Type, object?>();
        List<State> states = [];
        List<Information> informations = [];
        List<Transition> transitions = [];
        content.Add(typeof(List<State>), states);
        content.Add(typeof(List<Information>), informations);
        content.Add(typeof(List<Transition>), transitions);

        AddUIDataToStatesAndTransitions();
        var selectedModels = _diagram.GetSelectedModels().ToList();
        foreach (var sm in selectedModels)
        {
            if (sm is StateMachineStateNodeModel node)
            {
                var state = node.GetState(_automationProperties)!;
                states.Add(state);
            }
            else if (sm is StateMachineInformationNodeModel infnode)
            {
                var information = infnode.GetInformation(_automationProperties)!;
                informations.Add(information);
            }
        }
        foreach (var sm in selectedModels)
        {
            LinkModel? link = sm as LinkModel;
            if (link != null && link.Target is Blazor.Diagrams.Core.Anchors.SinglePortAnchor)
            {
                var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
                var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
                var sourceState = source.GetState(states);
                var targetState = target.GetState(states);
                if (sourceState != null && targetState != null)
                {
                    var transition = _automationProperties.Transitions.First(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
                    transitions.Add(transition);
                }
            }
        }

        ClipboardService.Copy("StateMachine", content);
    }


    void PasteFromClipboard(MenuItemEventArgs args)
    {
        var content = ClipboardService.Paste();
        content.TryGetValue(typeof(Automation), out object? automationObject);
        content.TryGetValue(typeof(List<State>), out object? statesObject);
        content.TryGetValue(typeof(List<Transition>), out object? transitionsObject);
        content.TryGetValue(typeof(List<Information>), out object? informationsObject);

        List<Transition> transitions = transitionsObject == null ? [] : (List<Transition>)transitionsObject!;
        List<State> states = statesObject == null ? [] : (List<State>)statesObject!;
        List<Information> informations = informationsObject == null ? [] : (List<Information>)informationsObject!;
        Automation? automation = automationObject == null ? null : (Automation)automationObject!;

        if (!transitions.Any() && !states.Any() && !informations.Any())
        {
            return;
        }

        AddUndo();

        if (automation != null)
        {
            Automation.IsSubAutomation = automation.IsSubAutomation;
            Automation.Enabled = automation.Enabled;
            AutomationProperties properties = new();
            if (!string.IsNullOrWhiteSpace(automation.Data))
            {
                properties = System.Text.Json.JsonSerializer.Deserialize<AutomationProperties>(automation.Data) ?? new();
            }
            _automationProperties.PreStartAction = properties.PreStartAction;
            _automationProperties.PreScheduleAction = properties.PreScheduleAction;
            transitions = properties.Transitions.ToList();
            states = properties.States.ToList();
            informations = properties.Informations.ToList();
        }

        int? minX = null;
        int? minY = null;

        foreach (var state in states.Where(x => !string.IsNullOrWhiteSpace(x.UIData)).ToList())
        {
            var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(state.UIData!);
            if (uiData != null && (minX == null || uiData.X < minX))
            {
                minX = uiData.X;
            }
            if (uiData != null && (minY == null || uiData.Y < minY))
            {
                minY = uiData.Y;
            }
        }
        foreach (var information in informations.Where(x => !string.IsNullOrWhiteSpace(x.UIData)).ToList())
        {
            var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(information.UIData!);
            if (uiData != null && (minX == null || uiData.X < minX))
            {
                minX = uiData.X;
            }
            if (uiData != null && (minY == null || uiData.Y < minY))
            {
                minY = uiData.Y;
            }
        }
        minX ??= 0;
        minY ??= 0;

        Dictionary<Guid, Guid> oldStateIdToNewId = [];
        var p = _diagram.GetRelativeMousePoint((int)args.ClientX, (int)args.ClientY);
        var existingStateNames = _automationProperties.States.Select(x => x.Name).Distinct().ToHashSet();
        foreach (var state in states)
        {
            var oldId = state.Id;
            if (existingStateNames.Contains(state.Name))
            {
                var index = 1;
                var orgName = state.Name;
                state.Name = $"{orgName}({index})";
                while (existingStateNames.Contains(state.Name))
                {
                    index++;
                    state.Name = $"{orgName}({index})";
                }
            }
            existingStateNames.Add(state.Name);
            var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(state.UIData!);
            var newState = AddNewState(state, (int)p.X + (uiData?.X ?? 0) - (minX ?? 0), (int)p.Y + (uiData?.Y ?? 0) - (minY ?? 0));
            oldStateIdToNewId.Add(oldId, newState.Id);
            _diagram.SelectModel(_diagram.GetNode(state)!, false);
        }

        foreach (var transition in transitions)
        {
            if (transition.FromStateId == null || transition.ToStateId == null) continue;

            LinkUIData? uiData = null;
            if (!string.IsNullOrWhiteSpace(transition.UIData))
            {
                uiData = System.Text.Json.JsonSerializer.Deserialize<LinkUIData>(transition.UIData!);
            }
            transition.FromStateId = oldStateIdToNewId[transition.FromStateId.Value];
            transition.ToStateId = oldStateIdToNewId[transition.ToStateId.Value];
            transition.Id = Guid.NewGuid();
            _automationProperties.Transitions.Add(transition);
            AddLink(transition, uiData?.SourcePort ?? PortAlignment.Bottom, uiData?.TargetPort ?? PortAlignment.Top);
        }

        foreach (var information in informations)
        {
            var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(information.UIData!);
            var newState = AddNewInformation(information, (int)p.X + (uiData?.X ?? 0) - (minX ?? 0), (int)p.Y + (uiData?.Y ?? 0) - (minY ?? 0));
            _diagram.SelectModel(_diagram.GetNode(information)!, false);
        }

        RefreshInformations();
        _diagram.Refresh();
    }

    Information AddNewInformation(Information information, int x, int y)
    {
        information.Id = Guid.NewGuid();
        _automationProperties.Informations.Add(information);

        var node = _diagram.Nodes.Add(new StateMachineInformationNodeModel(information, Automation, position: new Blazor.Diagrams.Core.Geometry.Point(x, y))
        {
            Title = information.Description ?? information.Evaluation ?? ""
        });

        return information;
    }


	ValueTask SelectAll(Blazor.Diagrams.Core.Diagram diagram)
    {
        foreach (var node in diagram.Nodes)
        {
            diagram.SelectModel(node, false);
        }
        foreach (var link in diagram.Links)
        {
            diagram.SelectModel(link, false);
        }
        return ValueTask.CompletedTask;
    }

    ValueTask DeleteSelection(Blazor.Diagrams.Core.Diagram diagram)
    {
        AddUndo();
        var selectedModels = diagram.GetSelectedModels().ToList();
        foreach (var sm in selectedModels)
        {
            LinkModel? link = sm as LinkModel;
            if (link != null)
            {
                RemoveLink(link);
            }
        }
        foreach (var sm in selectedModels)
        {
            NodeModel? node = sm as NodeModel;
            if (node != null)
            {
                RemoveNode(node);
            }
        }
        _diagram.Refresh();
        return ValueTask.CompletedTask;
    }

    void RemoveLink(LinkModel link)
    {
        var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link!.Source).Port.Parent;
        var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
        var sourceState = source.GetState(_automationProperties)!;
        var targetState = target.GetState(_automationProperties)!;
        var transition = _automationProperties.Transitions.First(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
        _automationProperties.Transitions.Remove(transition);
        _diagram.Links.Remove(link!);
    }

    void RemoveNode(NodeModel node)
    {
        if (node is StateMachineStateNodeModel smNode)
        {
            //should remove transitions as well
            var state = smNode.GetState(_automationProperties)!;
            var transitions = _automationProperties.Transitions.Where(x => x.FromStateId == state.Id || x.ToStateId == state.Id).ToList();
            foreach (var transition in transitions)
            {
                _automationProperties.Transitions.Remove(transition);
            }
            _automationProperties.States.Remove(state);
            _diagram.Nodes.Remove(node!);
        }
        else if (node is StateMachineInformationNodeModel infNode)
        {
            var information = infNode.GetInformation(_automationProperties)!;
            _automationProperties.Informations.Remove(information);
            _diagram.Nodes.Remove(node!);
        }
    }

	async Task AddStateAsync(int x, int y)
    {
        SaveAutomationPropertiesToAutomation();
        var state = await DialogService.ShowDialogAsync<AddOrEditStateDialog, State>("Add State", dialog =>
        {
            dialog.ExistingStateNames = _automationProperties.States.Select(x => x.Name).Distinct().ToHashSet();
            dialog.Automation = Automation;
			dialog.ScriptEditorType = ScriptEditorType;
			dialog.ScriptEngine = _scriptEngine;
        });
        if (state != null)
        {
            AddNewState(state, x, y);
            _diagram.Refresh();
        }
    }

    async Task EditStateAsync(NodeModel node)
    {
        SaveAutomationPropertiesToAutomation();
        var state = node.GetState(_automationProperties)!;
        var result = await DialogService.ShowDialogAsync<AddOrEditStateDialog, State>($"Edit State: {state.Name}", dialog =>
        {
            dialog.State = state;
            dialog.ExistingStateNames = _automationProperties.States.Where(x => x.Id != state.Id).Select(x => x.Name).Distinct().ToHashSet();
            dialog.Automation = Automation;
			dialog.ScriptEditorType = ScriptEditorType;
			dialog.ScriptEngine = _scriptEngine;
        });
        if (result != null)
        {
            AddUndo();
            state.Name = result.Name;
            state.Description = result.Description;
            state.EntryAction = result.EntryAction;
            state.IsErrorState = result.IsErrorState;
            state.IsStartState = result.IsStartState;
            state.IsSubState = result.IsSubState;
            state.SubStateParameters = result.SubStateParameters;
            state.SubStateMachineId = result.SubStateMachineId;

            node.Title = state.Name;
            node.Refresh();
        }
    }


	State AddNewState(State state, int x, int y)
    {
        state.Id = Guid.NewGuid();
        _automationProperties.States.Add(state);

        var node = _diagram.Nodes.Add(new StateMachineStateNodeModel(state, Automation, ScriptEditorType, _scriptEngine, position: new Blazor.Diagrams.Core.Geometry.Point(x, y))
        {
            Title = state.Name
        });

        node.AddPort(PortAlignment.Bottom);
        node.AddPort(PortAlignment.Top);
        node.AddPort(PortAlignment.Left);
        node.AddPort(PortAlignment.Right);
        return state;
    }


	Task ReloadDiagramAsync(Automation? useAutomation = null)
	{
		_diagram.Links.Clear();
		_diagram.Nodes.Clear();
		foreach (var state in _automationProperties.States)
		{
			var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(state.UIData!);
			var node = _diagram.Nodes.Add(new StateMachineStateNodeModel(state, Automation, ScriptEditorType, _scriptEngine, position: new Blazor.Diagrams.Core.Geometry.Point(uiData!.X, uiData.Y))
			{
				Title = state.Name
			});

			node.AddPort(PortAlignment.Bottom);
			node.AddPort(PortAlignment.Top);
			node.AddPort(PortAlignment.Left);
			node.AddPort(PortAlignment.Right);
		}
		foreach (var transition in _automationProperties.Transitions)
		{
			var uiData = System.Text.Json.JsonSerializer.Deserialize<LinkUIData>(transition.UIData!);
			AddLink(transition, uiData!.SourcePort, uiData!.TargetPort);
		}
		foreach (var information in _automationProperties.Informations)
		{
			var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(information.UIData!);
			var node = _diagram.Nodes.Add(new StateMachineInformationNodeModel(information, Automation, position: new Blazor.Diagrams.Core.Geometry.Point(uiData!.X, uiData.Y))
			{
				Title = information.Description ?? information.Evaluation ?? ""
			});
		}
		StateChanged(null, null);
		RefreshInformations();
		_diagram.Refresh();
		return Task.CompletedTask;
	}

	void AddLink(Transition transition, PortAlignment sourcePortAllignment, PortAlignment targetPortAllignment)
	{
		(var source, var target) = _diagram.GetNodes(transition, _automationProperties);
		var link = _diagram.Links.Add(new LinkModel(source!.Ports.First(x => x.Alignment == sourcePortAllignment), target!.Ports.First(x => x.Alignment == targetPortAllignment)));
		link.TargetMarker = LinkMarker.Arrow;
		link.AddLabel(transition.Description ?? transition.Condition ?? "true");
	}

	void StateChanged(object? sender, State? state)
	{
		InvokeAsync(() =>
		{
			//var currentState = stateMachineHandler.CurrentState;
			StateHasChanged();
		});
	}

	void RefreshInformations()
	{
		//todo
	}

    void AddUIDataToStatesAndTransitions()
    {
        foreach (var state in _automationProperties.States)
        {
            var uiData = new NodeUIData();
            var node = _diagram.GetNode(state)!;
            uiData.X = (int)node.Position.X;
            uiData.Y = (int)node.Position.Y;
            state.UIData = System.Text.Json.JsonSerializer.Serialize(uiData);
        }
        foreach (var link in _diagram.Links)
        {
            if (link.Target is Blazor.Diagrams.Core.Anchors.SinglePortAnchor)
            {
                var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
                var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
                var sourceState = source.GetState(_automationProperties)!;
                var targetState = target.GetState(_automationProperties)!;
                var transition = _automationProperties.Transitions.First(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
                var uiData = new LinkUIData();
                uiData.SourcePort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Alignment;
                uiData.TargetPort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Alignment;
                transition.UIData = System.Text.Json.JsonSerializer.Serialize(uiData);
            }
        }
        foreach (var information in _automationProperties.Informations)
        {
            var uiData = new NodeUIData();
            var node = _diagram.GetNode(information)!;
            uiData.X = (int)node.Position.X;
            uiData.Y = (int)node.Position.Y;
            information.UIData = System.Text.Json.JsonSerializer.Serialize(uiData);
        }
    }

    void SaveAutomationPropertiesToAutomation()
    {
        Automation.Data = System.Text.Json.JsonSerializer.Serialize(_automationProperties);
    }


    string? GetUndoData()
    {
        AddUIDataToStatesAndTransitions();
        SaveAutomationPropertiesToAutomation();
        return System.Text.Json.JsonSerializer.Serialize(Automation);
    }

    async Task OnImport(UploadChangeEventArgs args)
    {
        AddUndo();
        if (!args.Files.Any())
        {
            return;
        }
        var file = args.Files.First();
        var stream = file.OpenReadStream();
        var stateMachine = await System.Text.Json.JsonSerializer.DeserializeAsync<Automation>(stream);
        if (stateMachine != null)
        {
            await OnImport(stateMachine);
        }
    }

    async Task OnImport(Automation automation)
    {
        if (!string.IsNullOrWhiteSpace(automation.Data))
        {
            _automationProperties = System.Text.Json.JsonSerializer.Deserialize<AutomationProperties>(automation.Data) ?? new ();
        }
        else
        {
            _automationProperties = new();
        }
        SaveAutomationPropertiesToAutomation();
        await ReloadDiagramAsync(Automation);
    }

    private void AddUndo()
    {
        var data = GetUndoData();
        if (data != null)
        {
            _undoRedo.Add(data);
        }
    }

    async ValueTask UndoAsync(Blazor.Diagrams.Core.Diagram diagram)
    {
        if (CanUndo())
        {
            var data = _undoRedo.Undo();
            if (data != null)
            {
                var automation = System.Text.Json.JsonSerializer.Deserialize<Automation>(data);
                if (automation != null)
                {
                    await OnImport(automation);
                }
            }
        }
    }

    async ValueTask RedoAsync(Blazor.Diagrams.Core.Diagram diagram)
    {
        if (CanRedo())
        {
            var data = _undoRedo.Redo();
            if (data != null)
            {
                var automation = System.Text.Json.JsonSerializer.Deserialize<Automation>(data);
                if (automation != null)
                {
                    await OnImport(automation);
                }
            }
        }
    }

	bool CanUndo() => _undoRedo.CanUndo();
    bool CanRedo() => _undoRedo.CanRedo();

    void DiagramPointerMove(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        if (_draggingElement)
        {
            var relMouse = _diagram.GetRelativePoint(args.ClientX, args.ClientY); //pointer position on canvas element (top left = 0,0)
            var currentPan = _diagram.Pan;
            var moveX = 0;
            var moveY = 0;
            var stepSize = 20;
            var margin = 20;
            if (relMouse.X < margin)
            {
                moveX = stepSize;
            }
            else if (relMouse.X > _diagram.Container!.Width - margin)
            {
                moveX = -stepSize;
            }
            if (relMouse.Y < margin)
            {
                moveY = stepSize;
            }
            else if (relMouse.Y > _diagram.Container!.Height - margin)
            {
                moveY = -stepSize;
            }

            if (moveX != 0 || moveY != 0)
            {
                _diagram.SetPan(currentPan.X + moveX, currentPan.Y + moveY);
            }
        }
    }

    void DiagramPointerDown(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        if (args.Button == 0)
        {
            AddUndo();
        }
    }

    async void DiagramPointerUpAsync(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        _draggingElement = false;
        modelOnPointerUp = null;
        if (args.Button == 0)
        {
            //check if link is added
            var transitionEdited = false;
            foreach (var link in _diagram.Links.ToList())
            {
                if (link.Target.Model == null)
                {
                    _diagram.Links.Remove(link);
                    continue;
                }
                var source3 = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
                var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
                var sourceState = source3.GetState(_automationProperties)!;
                var targetState = target.GetState(_automationProperties)!;
                var transition = _automationProperties.Transitions.FirstOrDefault(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
                if (transition == null)
                {
                    transition = new()
                    {
                        FromStateId = sourceState.Id,
                        ToStateId = targetState.Id,
                        Id = Guid.NewGuid(),
                        Condition = _scriptEngine?.GetReturnTrueStatement(),
                        Description = "true"
                    };
                    _automationProperties.Transitions.Add(transition);
                    await EditTransitionAsync(link);
                    transitionEdited = true;
                }
            }

            if (!transitionEdited)
            {
                //maybe two to the same state? not allowed
                HashSet<string> existingTransitions = [];
                foreach (var link in _diagram.Links.ToList())
                {
                    var source3 = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
                    var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
                    var sourceState = source3.GetState(_automationProperties)!;
                    var targetState = target.GetState(_automationProperties)!;
                    var transition = _automationProperties.Transitions.FirstOrDefault(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
                    if (transition != null)
                    {
                        var key = $"{sourceState.Name}.{targetState.Name}";
                        if (existingTransitions.Contains(key))
                        {
                            _diagram.Links.Remove(link);
                        }
                        else
                        {
                            existingTransitions.Add(key);
                        }
                    }
                }
            }
        }
        else if (args.Button == 2)
        {
            modelOnPointerUp = model;
        }
    }

    async Task EditTransitionAsync(BaseLinkModel link)
    {
        SaveAutomationPropertiesToAutomation();
        var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
        var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
        var sourceState = source.GetState(_automationProperties)!;
        var targetState = target.GetState(_automationProperties)!;
        var transition = _automationProperties.Transitions.First(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
        var result = await DialogService.ShowDialogAsync<EditTransitionDialog, Transition>($"Edit Transition: {sourceState.Name} to {targetState.Name}", dialog =>
        {
            dialog.Transition = transition;
            dialog.Automation = Automation;
            dialog.ScriptEditorType = ScriptEditorType;
            dialog.ScriptEngine = _scriptEngine;
        });
        if (result != null)
        {
            AddUndo();
            transition.Condition = result.Condition;
            transition.Description = result.Description;

            link.Labels.Clear();
            link.AddLabel(transition.Description ?? result.Condition ?? "true");
            link.Refresh();
        }
    }

    async void DiagramPointerDoubleClickAsync(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        if (args.Button != 0) return;

        if (model is StateMachineStateNodeModel node)
        {
            await EditStateAsync(node);
        }
        // else if (model is StateMachineInformationNodeModel infnode)
        // {
        //     await EditInformationAsync(infnode);
        // }
        else if (model is LinkModel link)
        {
            await EditTransitionAsync(link);
        }
    }

}

