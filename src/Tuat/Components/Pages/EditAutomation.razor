@page "/editautomation/{Id:int}"
@using Tuat.Models
@using Tuat.Interfaces
@inject IAutomationService AutomationService
@inject DialogService DialogService
@inject IDataService DataService
@inject ContextMenuService ContextMenuService
@inject NavigationManager Navigation
@inject IUIEventRegistration UIEventRegistration
@inject IJSRuntime JS
@implements IDisposable

<style>
    .my-editor-class {
        height: 85vh;
    }
</style>

<PageTitle>HASM - Edit Script</PageTitle>

<NavigationLock ConfirmExternalNavigation="true"
                OnBeforeInternalNavigation="OnBeforeInternalNavigation" />

@if (Automation != null)
{
    <span>Edit Script: @Automation.Name (@(AutomationHandler?.RunningState.ToString() ?? "-"))</span>
    @if (!string.IsNullOrWhiteSpace(AutomationHandler?.ErrorMessage))
    {
        <p>@AutomationHandler.ErrorMessage</p>
    }
    <RadzenSplitter Orientation="Radzen.Orientation.Vertical" style="width: 100%;height: 95vh">
        <RadzenSplitterPane Size="75%" Min="300px">
            @if (!string.IsNullOrWhiteSpace(Automation.AutomationType))
            {
                <DynamicComponent @ref="automationEditor" Type="@(EditorComponentType())" Parameters="EditorPropertiesParameters" />
            }
        </RadzenSplitterPane>
        <RadzenSplitterPane Min="100px">
            <RadzenTabs>
                <Tabs>
                    <RadzenTabsItem Text="Variables">

 @*                        <VariablesControl Automation="Automation" AllowColumnPicking=false />
 *@
                    </RadzenTabsItem>
                    <RadzenTabsItem Text="Intermediate">
                        <div style="position: relative;">
                            <div style="position: absolute; top: 10px; right: 10px; z-index: 10;">
                                <RadzenButton Size="ButtonSize.Small" Text="Execute" Click="@ExecuteInteractive" Disabled="@(string.IsNullOrWhiteSpace(executeCommand) || AutomationHandler?.RunningState != AutomationRunningState.Active)" />
                            </div>
                            <RadzenTextArea @bind-Value=@executeCommand Style=@($"width:100%;") Rows="2" Placeholder="interactive javascript execution" />
                            <div>
                                <pre>@executeCommandResult</pre>
                            </div>
                        </div>
                    </RadzenTabsItem>
                    <RadzenTabsItem Text="Log">
                        <div style="position: relative;">
                            <div style="position: absolute; top: 10px; right: 10px; z-index: 10;">
                                <RadzenButton Size="ButtonSize.Small" Text="Clear" Click="@ClearLog" />
                                <RadzenButton Size="ButtonSize.Small" Text="@(_pauseLog ? "Continue" : "Pause")" Click="@PauseLog" />
                            </div>
                            <div style="width: 100%;height: 150px;border: 1px solid black; overflow: scroll">
                                @foreach (var data in logLines)
                                {
                                    <pre style="margin:0px;padding:0px;">@($"{data.Time.ToString("HH:mm.ss.fff")} {data.Message}")</pre>
                                }
                            </div>
                        </div>
                    </RadzenTabsItem>
                </Tabs>
            </RadzenTabs>
        </RadzenSplitterPane>
    </RadzenSplitter>
}
else
{
    <h2>Edit Script</h2>
}

@code {
    [Parameter]
    public int Id { get; set; }

    private sealed class LogData
    {
        public string Message { get; set; } = string.Empty;
        public DateTime Time { get; set; } = DateTime.Now;
    }

    private string? _unsavedData = null;
    private Automation Automation = null!;
    private IAutomationHandler AutomationHandler = null!;
    private readonly List<LogData> logLines = [];
    private string? executeCommand;
    private string? executeCommandResult;
    private bool _pauseLog;
    private DynamicComponent? automationEditor;
    Dictionary<string, object?>? EditorPropertiesParameters;

    private async Task<string?> GetAutomationDataAsync()
    {
        await SaveAutomationPropertiesToAutomationAsync();
        return System.Text.Json.JsonSerializer.Serialize(Automation);
    }

    Type? EditorComponentType()
    {
        return string.IsNullOrWhiteSpace(Automation?.AutomationType) ? null : Tuat.Generic.AutomationTypeDisplayNames.First(x => x.TypeName == Automation.AutomationType).EditorComponentType;
    }

    async Task ReloadScriptAsync(Automation? useAutomation)
    {
        Automation = useAutomation ?? AutomationHandler.Automation;
        _unsavedData = await GetAutomationDataAsync();
    }

    protected override async Task OnInitializedAsync()
    {
        AutomationHandler = AutomationService.GetAutomation(Id);
        Automation = AutomationHandler.Automation;
        EditorPropertiesParameters = new Dictionary<string, object?>() { { "Automation", Automation } };

        // UIEventRegistration.LogEntryAdded += LogEvent;
        // UIEventRegistration.ScriptHandlerInfoChanged += ScriptHandlerInfoChanged;
        // UIEventRegistration.AutomationHandlerChanged += AutomationHandlerChanged;
        // UIEventRegistration.AutomationInfoChanged += AutomationInfoChanged;
        // _unsavedData = System.Text.Json.JsonSerializer.Serialize(Automation);
        await base.OnInitializedAsync();
    }

    public void Dispose()
    {
        // UIEventRegistration.AutomationInfoChanged -= AutomationInfoChanged;
        // UIEventRegistration.AutomationHandlerChanged -= AutomationHandlerChanged;
        // UIEventRegistration.LogEntryAdded -= LogEvent;
        // UIEventRegistration.ScriptHandlerInfoChanged -= ScriptHandlerInfoChanged;
    }

    void LogEvent(object? sender, LogEntry logEntry)
    {
        if (_pauseLog || logEntry.AutomationId != Automation?.Id) return;

        InvokeAsync(() =>
        {
            logLines.Add(new LogData() { Message = logEntry.Message, Time = logEntry.Timestamp.ToLocalTime() });
            while (logLines.Count > 200)
            {
                logLines.RemoveAt(0);
            }
            StateHasChanged();
        });
    }

    // private void ScriptHandlerInfoChanged(object? sender, ScriptHandler.ScriptHandlerInfo scriptInfo)
    // {
    //     InvokeAsync(() =>
    //     {
    //         StateHasChanged();
    //     });
    // }

    // private void AutomationHandlerChanged(object? sender, IAutomationHandler automationHandler)
    // {
    //     InvokeAsync(async () =>
    //     {
    //         if (automationHandler.Automation.Id < 0)
    //         {
    //             NavigationManager.NavigateTo("\\");
    //         }
    //         else
    //         {
    //             await ReloadScriptAsync(null);
    //         }
    //     });
    // }

    // private void AutomationInfoChanged(object? sender, AutomationInfo scriptInfo)
    // {
    //     if (scriptInfo.AutomationId != Automation?.Id)
    //     {
    //         return;
    //     }
    //     InvokeAsync(StateHasChanged);
    // }

    private async Task OnBeforeInternalNavigation(LocationChangingContext context)
    {
        if (_unsavedData != await GetAutomationDataAsync())
        {
            var isConfirmed = await JS.InvokeAsync<bool>("confirm", "Changes are not saved. Are you sure you want to leave the page without saving changes?");

            if (!isConfirmed)
            {
                context.PreventNavigation();
            }
        }
    }

    void ClearLog()
    {
        InvokeAsync(() =>
    {
        logLines.Clear();
        StateHasChanged();
    });
    }

    void PauseLog()
    {
        _pauseLog = !_pauseLog;
    }

    void ExecuteInteractive()
    {
        if (!string.IsNullOrWhiteSpace(executeCommand))
        {
            executeCommandResult = null;
            if (AutomationHandler?.RunningState == AutomationRunningState.Active)
            {
                executeCommandResult = AutomationHandler.ExecuteScript(executeCommand);
            }
            else
            {
                executeCommandResult = "error: script not active";
            }
            InvokeAsync(StateHasChanged);
        }
    }

    Task SaveAutomationPropertiesToAutomationAsync()
    {
		return Task.CompletedTask;
    }
}
